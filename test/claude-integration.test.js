/**
 * Unit Tests for Claude Code Integration Components
 * Tests the new enhancement features for security and functionality
 */

const fs = require('fs-extra');
const path = require('path');
const { SlashCommandGenerator } = require('../lib/claude-integration/SlashCommandGenerator');
const { StatuslineProvider } = require('../lib/claude-integration/StatuslineProvider');
const { SettingsOptimizer } = require('../lib/claude-integration/SettingsOptimizer');

// Test configuration
const testProjectPath = path.join(__dirname, 'test-project');

describe('Claude Code Integration Tests', () => {
  
  beforeAll(async () => {
    // Setup test environment
    await fs.ensureDir(testProjectPath);
  });

  afterAll(async () => {
    // Cleanup test environment
    await fs.remove(testProjectPath);
  });

  describe('SlashCommandGenerator', () => {
    let generator;
    
    beforeEach(() => {
      generator = new SlashCommandGenerator();
    });

    test('should validate agent names correctly', () => {
      expect(generator.validateAgentName('project-orchestrator-agent')).toBe(true);
      expect(generator.validateAgentName('frontend_development')).toBe(true);
      expect(generator.validateAgentName('')).toBe(false);
      expect(generator.validateAgentName(null)).toBe(false);
      expect(generator.validateAgentName('agent with spaces')).toBe(false);
    });

    test('should sanitize agent names properly', () => {
      expect(generator.sanitizeAgentName('project-orchestrator-agent')).toBe('project-orchestrator-agent');
      expect(generator.sanitizeAgentName('Frontend Development!')).toBe('frontenddevelopment');
      expect(generator.sanitizeAgentName('test@agent#')).toBe('testagent');
    });

    test('should validate descriptions and prevent XSS', () => {
      expect(generator.validateDescription('Valid description')).toBe(true);
      expect(generator.validateDescription('<script>alert("xss")</script>')).toBe(false);
      expect(generator.validateDescription('javascript:void(0)')).toBe(false);
      expect(generator.validateDescription('$(rm -rf /)')).toBe(false);
    });

    test('should generate command content with security headers', () => {
      const agent = {
        name: 'test-agent',
        description: 'Test agent for development',
        specialty: 'testing'
      };
      
      const content = generator.generateAgentCommandContent(agent);
      expect(content).toContain('Security Check');
      expect(content).toContain('@Task(');
      expect(content).toContain('Generated by mega-minds SlashCommandGenerator');
    });

    test('should prevent path traversal in command generation', async () => {
      const maliciousAgent = {
        name: '../../../malicious',
        description: 'Malicious agent',
        specialty: 'hacking'
      };
      
      expect(() => generator.validateAgent(maliciousAgent)).toThrow();
    });
  });

  describe('StatuslineProvider', () => {
    let provider;
    
    beforeEach(() => {
      provider = new StatuslineProvider(null, {
        enableColors: false, // Disable for testing
        enableEmojis: false
      });
    });

    test('should generate statusline without errors', async () => {
      const status = await provider.generateStatus();
      expect(typeof status).toBe('string');
      expect(status.length).toBeGreaterThan(0);
    });

    test('should handle missing aiDevTeam gracefully', async () => {
      const status = await provider.generateStatus();
      expect(status).toContain('mega-minds');
    });

    test('should respect update interval', async () => {
      const status1 = await provider.generateStatus();
      const status2 = await provider.generateStatus();
      expect(status1).toBe(status2); // Should be cached
    });

    test('should generate statusline script', async () => {
      const scriptPath = await provider.generateStatuslineScript(testProjectPath);
      expect(await fs.pathExists(scriptPath)).toBe(true);
      
      const scriptContent = await fs.readFile(scriptPath, 'utf8');
      expect(scriptContent).toContain('#!/usr/bin/env node');
      expect(scriptContent).toContain('StatuslineProvider');
    });
  });

  describe('SettingsOptimizer', () => {
    let optimizer;
    let mockProjectAnalyzer;
    
    beforeEach(() => {
      mockProjectAnalyzer = {
        analyzeProject: jest.fn().mockResolvedValue({
          projectType: 'development',
          techStack: { languages: ['JavaScript'] }
        })
      };
      optimizer = new SettingsOptimizer(mockProjectAnalyzer);
    });

    test('should select appropriate model based on complexity', () => {
      const simpleProject = { complexity: 'low' };
      const complexProject = { complexity: 'high', techStack: { languages: ['JS', 'Python', 'Go', 'Rust'] } };
      
      expect(optimizer.selectOptimalModel(simpleProject)).toBe('sonnet');
      expect(optimizer.selectOptimalModel(complexProject)).toBe('opus');
    });

    test('should determine tools based on project needs', () => {
      const projectWithBash = { hasPackageJson: true, hasGit: true };
      const tools = optimizer.determineOptimalTools(projectWithBash);
      
      expect(tools).toContain('Task');
      expect(tools).toContain('Read');
      expect(tools).toContain('Write');
      expect(tools).toContain('Bash');
    });

    test('should validate settings before returning', () => {
      const invalidSettings = { allowedTools: [] };
      expect(() => optimizer.validateSettings(invalidSettings)).toThrow();
    });

    test('should generate secure permissions', async () => {
      const projectAnalysis = {
        hasPackageJson: true,
        needsNetwork: false
      };
      
      const permissions = await optimizer.generateSecurePermissions(projectAnalysis);
      expect(permissions.file_write).toBe(true);
      expect(permissions.bash).toBe(true);
      expect(Array.isArray(permissions.excluded_paths)).toBe(true);
      expect(permissions.excluded_paths).toContain('node_modules/**');
      expect(permissions.excluded_paths).toContain('**/.env*');
    });

    test('should generate fallback settings on error', () => {
      const fallback = optimizer.generateFallbackSettings();
      expect(fallback.model).toBe('sonnet');
      expect(Array.isArray(fallback.allowedTools)).toBe(true);
      expect(fallback.permissions.file_write).toBe(true);
    });
  });

  describe('Security Features', () => {
    test('SlashCommandGenerator should prevent command injection', () => {
      const generator = new SlashCommandGenerator();
      const maliciousDescription = 'Valid desc; rm -rf /; echo "hacked"';
      
      expect(generator.validateDescription(maliciousDescription)).toBe(false);
    });

    test('SettingsOptimizer should restrict dangerous file access', async () => {
      const optimizer = new SettingsOptimizer(null);
      const permissions = await optimizer.generateSecurePermissions({});
      
      expect(permissions.excluded_paths).toContain('**/.env*');
      expect(permissions.excluded_paths).toContain('**/secrets/**');
    });

    test('StatuslineProvider should sanitize output', async () => {
      const provider = new StatuslineProvider();
      const maliciousContext = {
        sessionId: '<script>alert("xss")</script>',
        model: 'test"malicious'
      };
      
      const status = await provider.generateStatus(maliciousContext);
      expect(status).not.toContain('<script>');
      expect(status).not.toContain('"malicious');
    });
  });

  describe('Integration Tests', () => {
    test('should initialize all components together', async () => {
      const { initializeClaudeIntegration } = require('../lib/claude-integration');
      
      const mockAnalysis = {
        agents: [
          { name: 'test-agent', description: 'Test agent' }
        ],
        projectType: 'development',
        techStack: { languages: ['JavaScript'] }
      };
      
      const results = await initializeClaudeIntegration(testProjectPath, mockAnalysis, null);
      
      expect(results).toHaveProperty('slashCommands');
      expect(results).toHaveProperty('statusline');
      expect(results).toHaveProperty('settings');
      expect(Array.isArray(results.errors)).toBe(true);
    });
  });
});

// Mock implementations for testing
jest.mock('fs-extra');
jest.mock('child_process');

// Setup test environment
global.console = {
  log: jest.fn(),
  error: jest.fn(),
  warn: jest.fn()
};